package com.dev.specification.repository.specification.phone;

import com.dev.specification.exception.FilterIllegalArgumentException;
import com.dev.specification.model.Phone;
import com.dev.specification.repository.specification.SpecificationProvider;
import jakarta.persistence.criteria.Predicate;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Component;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

/**
 * This class provides a specification for filtering Phone entities based on price range.
 * It implements the SpecificationProvider interface for Phone entities.
 * The price range filter can be applied through the 'price' query parameter.
 * The specification generated by this class allows filtering Phones based on a minimum and/or maximum price.
 * If only one price is provided, it filters Phones with a price greater than or equal to that value.
 * If two prices are provided, it filters Phones within the specified price range.
 *
 * Example usage:
 * - To filter Phones with a price greater than or equal to 150, use: price=150
 * - To filter Phones within the price range of 150 to 200, use: price=150,200
 * - To filter Phones with a price less than or equal to 200, use: price=,200
 * - If filter is passed like this: price=150,200,300 with more than 2 prices values -
 * A value of 300 will be ignored and the search will occur from 150 to 200
 **/

@Component
public class PhonePriceRangSpecification implements SpecificationProvider<Phone> {
    private static final String FILTER_KEY = "price";
    private static final String FIELD_PARAM = "price";

    @Override
    public Specification<Phone> getSpecification(String[] prices) {
        Optional<Double> minPriceOpt = getDoubleFromString(prices.length > 0 ? prices[0] : null);
        Optional<Double> maxPriceOpt = getDoubleFromString(prices.length > 1 ? prices[1] : null);

        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();

            minPriceOpt.ifPresent(min -> predicates.add(
                    criteriaBuilder.greaterThanOrEqualTo(root.get(FIELD_PARAM), min))
            );
            maxPriceOpt.ifPresent(max -> predicates.add(
                    criteriaBuilder.lessThanOrEqualTo(root.get(FIELD_PARAM), max))
            );

            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }

    @Override
    public String getFilterKey() {
        return FILTER_KEY;
    }

    private Optional<Double> getDoubleFromString(String param) {
        return Optional.ofNullable(param)
                .filter(year -> !year.trim().isEmpty())
                .map(max -> {
                    try {
                        return Double.parseDouble(max.trim());
                    } catch (NumberFormatException e) {
                        throw new FilterIllegalArgumentException("Invalid max price format: " + max);
                    }
                });
    }
}
